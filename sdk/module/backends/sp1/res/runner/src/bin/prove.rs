use args::parse_args;
use sp1_sdk::{ProverClient, SP1Stdin};
use hex;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const PROGRAM_ELF: &[u8] = include_bytes!("../../../builder/target/elf-compilation/riscv32im-succinct-zkvm-elf/release/sp1-program");

fn main() {
    sp1_sdk::utils::setup_logger();
    let client = ProverClient::new();
    let (pk, vk) = client.setup(PROGRAM_ELF);
    let mut stdin = SP1Stdin::new();

    let args = parse_args().unwrap();
    for arg in args {
        match arg.kind.as_str() {
            "uint32" => {
                stdin.write::<u32>(&u32::from_str_radix(&arg.value, 10).unwrap());
            }
            "bytearray" => {
                stdin.write_slice(&hex::decode(&arg.value).unwrap());
            },
            "file" => {
                let buffer = std::fs::read("/sp1_target/input.file").unwrap();
                let buf_slice = buffer.as_slice();
                stdin.write_slice(&buf_slice);
            }
            _ => {
                eprintln!("Unknown argument kind: {}", arg.kind);
            }
        }
    }

    let (output, report) = client.execute(PROGRAM_ELF, stdin.clone()).run().unwrap();
    let proof = client.prove(&pk, stdin).run().unwrap();
    client.verify(&proof, &vk).unwrap();
    proof
        .save("/tmp/proofs/sp1Proof.bin")
        .expect("saving proof failed");
    println!("Output: {:?}", output);
    println!("Report: {:?}", report);
}
